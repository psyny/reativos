#include "sdl.ceu"

#define DEBUG_LV 0
#define USE_THREAD 0
#define	USE_PARTICLES 1
#define SHOW_FPS 0
#define USER_INTERFACE 1

#define SPEED 150
#define MAX_HUNTERS 5

// PARTICLES_PER_PLAYER_PARCEL is to be the ( MAX desired particles / 10 )
#define PARTICLES_PER_PLAYER_PARCEL 10
#define PARTICLES_PER_ENEMY_PARCEL 10

#define WIN_W 500000
#define WIN_H 500000

#define CORCAVEIRA RGBA( 0xAA , 0xAA , 0xAA , 0 )
#define CORCAVEIRA2 RGBA( 0xCC , 0xCC , 0xCC , 0 )
#define CORPLAYER1 RGBA( 0xFF , 0x00 , 0x00 , 0 )
#define CORPLAYER2 RGBA( 0x00 , 0xDD , 0xFF , 0 )
#define CORPLAYER3 RGBA( 0x55 , 0xDD , 0x00 , 0 )

#define PI 3.14159265

// Celulas para o Pathfinding
#define PATH_CELLS_X 50
#define PATH_CELLS_Y 50
// Intervalo de atalização do caminho ( ms )
#define GRID_UPDATE_INTERVAL 100
#define PATH_UPDATE_INTERVAL 200
#define RENDEZVOUS_UPDATE_INTERVAL 3000

native @nohold _printf;
native @nohold _AST_findPath;

// Modulo de caminho do corpo do Boitata
#include "BodyPath.ceu"

// Modulo do A*
#include "AStar.ceu"

// Console
native do
	void COM_askPlayersQty(int* r_qtd , int* r_dif) {
		int qtd = 0;
		int diff = 0;
		
		printf("\nBOITATA!\n");
		
		while( qtd<= 0 || qtd > 3) {
			printf("Digite a quantidade de jogadores ( de 1 a 3 ):");
			scanf(" %d", &qtd);
		}
		
		while( diff<= 0 || diff > 3) {
			printf("\nNivel de dificuldade\n1 - Facil\n2 - Medio\n3 - Dificil\nDigite a dificuldade:");
			scanf("%d", &diff);
		}	
		
		(*r_qtd) = qtd;
		(*r_dif) = diff;	
	}
end


// Configuracoes da partida
var int tempPlayerQTD = 1;
var int tempDifficuty = 1;
var int gameSet		  = 0;
var int[4] totalScoreValues 	= [0,0,0,0];
var int[4] totalScoreHunters 	= [0,0,0,0];	
#if USER_INTERFACE == 0 
	_COM_askPlayersQty( &&tempPlayerQTD , &&tempDifficuty ) finalize with end; 
#endif


// Janela e Render
input void SDL_REDRAW;
input void SDL_QUIT;
input int  SDL_DT;
input _SDL_KeyboardEvent&& SDL_KEYDOWN;
input _SDL_KeyboardEvent&& SDL_KEYUP;
input _SDL_MouseButtonEvent&& SDL_MOUSEBUTTONDOWN;

var _SDL_Renderer&? renderer;

#if USER_INTERFACE == 0
var _SDL_Window&? window;
    finalize
        window = &_SDL_CreateWindow("Boitata", _SDL_WINDOWPOS_UNDEFINED, _SDL_WINDOWPOS_UNDEFINED, WIN_W/1000 , WIN_H/1000 , _SDL_WINDOW_SHOWN);
    with
        _SDL_DestroyWindow(&&window!);
    end
    finalize
        renderer = &_SDL_CreateRenderer(&&window!, -1, 0);
    with
        _SDL_DestroyRenderer(&&renderer!);
    end
#else
	// User Interface ( WIP )
	var SDL sdl = SDL.build(_SDL_INIT_EVERYTHING, WIN_W/1000 , WIN_H/1000 , "Boitata");
	renderer = &sdl.ren;
#endif

// Geometry and Physics
#include "geo.ceu"

// Special Effects
#include "sfx.ceu"

// Text Scribbler
#include "scribbler.ceu"	

// Contador de quadros
class FrameCounter with
    event void destroy;
do
    par/or do
    	#if SHOW_FPS == 1
        loop do
            var int frames = 0;
            watching 1s do
                every dt in SDL_DT do
                    frames = frames + 1;
                end
            end
            	_printf("\nFPS: %d",frames);
        end
        #endif
    with
        await this.destroy;
    end
end 

// Organismo que controla os dados do jogo
class GameData with
 	var int totalPlayers 	= 1;
 	var int	alivePlayers 	= 1;
 	var int difficulty 		= 1;
	var int gameSpeed		= SPEED;
	var float enemySpeedScale = 1.5;
	
	var int[4]& scoreValues;
	var int[4]& scoreHunters;	
	
	event void destroy;
do
	// Ajuste de dificuldade

	this.gameSpeed = 150 + ( ( (int)( ( difficulty - 0.1 ) / 2 ) ) * 50 );
	
	if difficulty%2 == 1 then
		this.enemySpeedScale = 1.4;
	else
		this.enemySpeedScale = 1.5;
	end
		
	await this.destroy;
end

// Controla fluxo do jogo ( aperte qualquer tecla para continuar )
class AnyKeyContinue with
	event void pressed;
do
	var _SDL_KeyboardEvent&& key;      
	key = await SDL_KEYUP;

	emit this.pressed;
end

// Controle de menu de selecao
class MenuControls with
	var int selected 	= 0;
	var int maxOptions	= 2;
	
	var int direction = 0;
	var int circle = 0;
	
	event void changed;
	event void confirmed;
	event void destroy;
do
	var int keyNext = 0;
	var int keyPrev = 0;
	
	if direction == 0 then
		keyNext = _SDLK_RIGHT;
		keyPrev = _SDLK_LEFT;
	else
		keyNext = _SDLK_UP;
		keyPrev = _SDLK_DOWN;	
	end
	
	par/or do
		loop do
			// Pressiona tecla
		    par/or do
		    	var _SDL_KeyboardEvent&& key;
		    	key = await SDL_KEYDOWN   until key:keysym.sym==keyNext;
		    	selected = selected + 1;
		    	if selected > (maxOptions-1) then
		    		if circle == 0 then
		    			selected = (maxOptions-1);
		    		else
		    			selected = 0;
		    		end
		    	end
		    	emit this.changed; 	
		    with
		    	var _SDL_KeyboardEvent&& key;
		    	key = await SDL_KEYDOWN   until key:keysym.sym==keyPrev;
		    	selected = selected - 1;
		    	if selected < 0 then
		    		if circle == 0 then
		    			selected = 0;
		    		else
		    			selected = (maxOptions-1);
		    		end
		    	end
		    	emit this.changed;
		    with
		    	var _SDL_KeyboardEvent&& key;
		    	key = await SDL_KEYDOWN   until key:keysym.sym==_SDLK_RETURN;
		    	emit this.confirmed;
		    end 
		    
		    // Solta tecla
		    par/or do
		    	var _SDL_KeyboardEvent&& key;
		    	key = await SDL_KEYUP   until key:keysym.sym==keyNext;      
		    with
		    	var _SDL_KeyboardEvent&& key;
		    	key = await SDL_KEYUP   until key:keysym.sym==keyPrev;
		    with
		    	var _SDL_KeyboardEvent&& key;
		    	key = await SDL_KEYUP   until key:keysym.sym==_SDLK_RETURN;
		    end		
		end	
	with
		await this.destroy;
	end
end

// Controle do jogador
class PlayerControls with
	var GEO_PolarPhysOrganism& character;
	var int player = 0;
	
	var int	defaultRadius = 30;
	
	var int confirmFlag = 1;
	
	event void enableControl; // Da controle ao jogador
	event void disableControl; // Retira controle do jogador
	
	event void awaitForConfirm;
	event void confirmed;
	
	event void destroy;
do
	var float multi = 1000.0;
	var int turnDirection = 0;
	var int pilhaA = 0;
	var int pilhaB = 0;
	
	var int keyLeft = 0;
	var int keyRight = 0;
	var int keyUp = 0;
	var int keyDown = 0;	
	
	if player == 0 then
		keyLeft = _SDLK_LEFT;
		keyRight = _SDLK_RIGHT;
		keyUp = _SDLK_UP;
		keyDown = _SDLK_DOWN;
	end
	
	if player == 1 then
		keyLeft = _SDLK_a;
		keyRight = _SDLK_d;
		keyUp = _SDLK_w;
		keyDown = _SDLK_s;	
	end
	
	if player == 2 then
		keyLeft = _SDLK_KP_4;
		keyRight = _SDLK_KP_6;
		keyUp = _SDLK_KP_8;
		keyDown = _SDLK_KP_5;	
	end
	
	// Life Loop
	par/or do
		loop do
			par/or do
				await this.disableControl;  	
			with		
				// Controle Direcional da Curva: reação quando solta as teclas ESQ ou DIR
				loop do
					par/or do
						var _SDL_KeyboardEvent&& key;
						key = await SDL_KEYUP   until key:keysym.sym==keyLeft;
					with
						var _SDL_KeyboardEvent&& key;
						key = await SDL_KEYUP   until key:keysym.sym==keyRight;
					end  
					pilhaA = pilhaA - 1;
					if( pilhaA <= 0 ) then
						pilhaA = 0;
						turnDirection = 0;
						character.angularVelocity = 0;
					end 		
				end
			with
				// Controle Direcional da Curva: reação quando aperta ESQ
				finalize with 
					character.angularVelocity = 0;
				end
				loop do
					var _SDL_KeyboardEvent&& key;
					key = await SDL_KEYDOWN until key:keysym.sym==keyLeft;
					turnDirection = -1;
					character.angularVelocity = ( character.velocityIntensity / ( defaultRadius * multi ) )  * turnDirection;
					pilhaA = pilhaA + 1;
					key = await SDL_KEYUP   until key:keysym.sym==keyLeft;
				end
			with
				// Controle Direcional da Curva: reação quando aperta DIR
				finalize with 
					character.angularVelocity = 0;
				end
				loop do
					var _SDL_KeyboardEvent&& key;
					key = await SDL_KEYDOWN until key:keysym.sym==keyRight;
					turnDirection = 1;
					character.angularVelocity = ( character.velocityIntensity / ( defaultRadius * multi ) )  * turnDirection;
					pilhaA = pilhaA + 1;
					key = await SDL_KEYUP   until key:keysym.sym==keyRight;
				end
			with
				// Controle Raio da Curva: reação quando solta as teclas CIMA ou BAIXO
				loop do
					par/or do
						var _SDL_KeyboardEvent&& key;
						key = await SDL_KEYUP   until key:keysym.sym==keyUp;
					with
						var _SDL_KeyboardEvent&& key;
						key = await SDL_KEYUP   until key:keysym.sym==keyDown;
					end  
					pilhaB = pilhaB - 1;
					if( pilhaB <= 0 ) then
						pilhaB = 0;
						multi = 1000.0;
						character.angularVelocity = ( character.velocityIntensity / ( defaultRadius * multi ) )  * turnDirection;
					end 		
				end
			with
				// Controle Raio da Curva: reação quando aperta CIMA: Diminui raio da Curva
				loop do
					var _SDL_KeyboardEvent&& key;
					key = await SDL_KEYDOWN until key:keysym.sym==keyUp;
					multi = 500.0;	        
					character.angularVelocity = ( character.velocityIntensity / ( defaultRadius * multi ) )  * turnDirection;
					key = await SDL_KEYUP   until key:keysym.sym==keyUp;
				end     
			with
				// Controle Raio da Curva: reação quando aperta BAIXO: Aumenta raio da Curva
				loop do
					var _SDL_KeyboardEvent&& key;
					key = await SDL_KEYDOWN until key:keysym.sym==keyDown;
					//_BPT_printChain(1); //DEBUG
					multi = 2000.0;
					character.angularVelocity = ( character.velocityIntensity / ( defaultRadius * multi ) )  * turnDirection;
					key = await SDL_KEYUP   until key:keysym.sym==keyDown;
				end             
			end	
			
			await this.enableControl;	
		end
	with
	// Loop de espera de confirmação de uma tecla pressionada
		loop do
			// Aguarda confirmação do jogador: Jogador apertar qualquer tecla para resumir o comando
			await this.awaitForConfirm;
			confirmFlag = 0;
			
			var _SDL_KeyboardEvent&& key;
			key = await SDL_KEYUP until 
				( 	key:keysym.sym==keyDown
				or 	key:keysym.sym==keyUp
				or 	key:keysym.sym==keyLeft
				or 	key:keysym.sym==keyRight
				);
			confirmFlag = 1;
			
			emit this.confirmed;		
		end
	with
	// Monitora hora de destruir o organismo
		await this.destroy;
	end
end

// Organismo que aguarda a confirmação de todos os jogadores
class AwaitForConfirm with
	pool PlayerControls[]& 	playerCONs;
	
	var int 	disableUntilConfirm		= 1;
	
	var int[]	confirmedPlayers;
	
	event void allConfirmed;
	event void destroy;
do
	// Captura todos os player controls do pool
	var PlayerControls&&?[] pcons;
	loop pcon in playerCONs do
		confirmedPlayers = []..confirmedPlayers..[0];
		pcons = []..pcons..[pcon];
	end		
	
	// BUG: Tem q ter esse await para o emit seguinte funcionarem
	await 1ms; 
	
	// Retira controle dos jogadores	
	if disableUntilConfirm == 1 then		
		loop i in $pcons do 
			if pcons[i]? then
				emit pcons[i]!:disableControl;
			end
		end	
	end
			
	// Aguarda por todos os jogadores pressionarem uma tecla
	loop i in $pcons do 
		if pcons[i]? then
			emit pcons[i]!:awaitForConfirm;
		end
	end	
	
	loop do
		var int playersConfirmed = $pcons;
		await SDL_REDRAW;
		loop i in $pcons do 
			if pcons[i]? and pcons[i]!:confirmFlag == 1 then
				playersConfirmed = playersConfirmed - 1;
				confirmedPlayers[pcons[i]!:player] = 1;
			end
		end	
		
		if playersConfirmed <= 0 then
			break;
		end
	end	
	
	// Confirma 
	emit this.allConfirmed;
	
	// Finaliza
	await this.destroy;
	
	// Devolve controle aos jogadores
	if disableUntilConfirm == 1 then	
		loop i in $pcons do 
			if pcons[i]? then
				emit pcons[i]!:enableControl;
			end
		end
	end	
end
  
// Cabeça do boitata
/*
    É controlada por um jogador e geradora da estrutura de caminho para um corpo seguir
*/
class BoitataHead with
	var _SDL_Renderer& 			ren;	
	var GEO_PolarPhysOrganism& 	character;	 
	
	var RGBA	color			= RGBA( 0xff , 0xff , 0xff , 0 );
	
	function (void)=>GEO_Circloid& getCircloid;
	
	event void dieFX;
do
	// Cabeça
	var GEO_Circloid head with
		this.ren = &ren;
		this.radius = 12;
		this.center = character.position;
		this.color = color;
	end;

	function (void)=>GEO_Circloid& getCircloid do
		return &(this.head); 
	end;
	
	// Posicao inicial ao caminho
	var Vetor2D position = character.getPosition();

	// Olhos
	var GEO_Circloid[2] olhos with 
		this.ren = &ren;
		this.radius = 4;
		this.center = character.position;
		this.color = RGBA( 0x00 , 0x00 , 0x60 , 0x00 );
	end;	

	// Loop funcional
	par/or do
		every dt in SDL_DT do
			position = character.getPosition();
		
			// Posicao da cabeça		
			head.center.x = position.x;
			head.center.y = position.y;
		
			// Posicao dos olhos
			olhos[0].center.x = position.x + ( _cos( character.velocityDirection + PI/4 ) * ( head.radius / 2 ) );
			olhos[0].center.y = position.y + ( _sin( character.velocityDirection + PI/4 ) * ( head.radius / 2 ) );
			olhos[1].center.x = position.x + ( _cos( character.velocityDirection - PI/4 ) * ( head.radius / 2 ) );
			olhos[1].center.y = position.y + ( _sin( character.velocityDirection - PI/4 ) * ( head.radius / 2 ) );	
			
			// Atualiza o caminho
			_BPT_updateFinish( this.character.player , position.x , position.y );	
		end
	with
	// Criação de nodes
		loop do
			await 100ms;
			_BPT_addViceNode( this.character.player );
		end
	with 
	// Efeitos visuais da morte
		await dieFX;
		head.color = CORCAVEIRA2;
		olhos[0].color = RGBA( 0x00 , 0x00 , 0x00 , 0x00 );	
		olhos[1].color = RGBA( 0x00 , 0x00 , 0x00 , 0x00 );
		await FOREVER;	
	end	
end



// Corpo do Boitata
class BoitataBody with
	var _SDL_Renderer& 	ren;
	var GEO_PolarPhysOrganism& 	character;
	
	var int&	speed;
	var int		node;	
	
	var int 	minDist		= 10;
	var int		size		= 10;
	var int 	darker		= 0;
	
	var int		onFire		= 1;
	var RGBA	color		= RGBA(0xFF,0xFF,0xFF,0);
	var int 	colorStyle	= 1;
	
	var float 	headDist 	= 1;
	var int		colision	= 1;
	
	function (void)=>GEO_Circloid& getCircloid;
	
	var WindField&		windField;
	pool Flame[]& 		flamePool;
	pool Spark[]& 		dimSparkPool;
	pool Spark[]& 		brightSparkPool;
	
	event void destroy;
	event void disableFire;
	event void enableFire;
do		
	var GEO_Circloid body with
		var int x = 0;
		var int y = 0;
		_BPT_getNodePos( &&node , &&x , &&y ) finalize with end;	
		this.ren = &ren;
		this.radius = size;	
		this.center = Vetor2D( x , y );	
	
		this.color = color;
	
		// colorStyle == 0 : cor igual a passada pelo pai
			
		if colorStyle == 1 then
		// ColorStyle == 1 : com listras
			if darker == 1 then
				this.color.r = 	( 0.7 * this.color.r );
				this.color.g = 	( 0.7 * this.color.g );
				this.color.b = 	( 0.7 * this.color.b );		
			end
		else/if colorStyle == 2 then
		// ColorStyle == 1 : com variação aleatoria
			var float colorVariation;
			colorVariation = (1.0 * (_rand()%20) / 100);
			this.color.r = 	( this.color.r * colorVariation ) +  ( 0.8 * this.color.r );
			this.color.g = 	( this.color.g * colorVariation ) +  ( 0.8 * this.color.g );
			this.color.b = 	( this.color.b * colorVariation ) +  ( 0.8 * this.color.b );	
		end	
		

	end;
	
	function (void)=>GEO_Circloid& getCircloid do
		return &(this.body); 
	end;
	
	// Fire effect emitter
	var GEO_Area effectArea with
		this.type			= 3;
		this.center			= body.center;
		this.attribute1		= body.radius;
	end;
	
	#if USE_PARTICLES == 1
	var FireEmitter	fireEmitter with
		this.ren 			= &ren;
		this.windField		= &windField;
		this.emitterArea 	= &effectArea;
		this.flamePool 		= &flamePool;
		this.dimSparkPool 		= &dimSparkPool;
		this.brightSparkPool 	= &brightSparkPool;
				
		this.emitInterval 	= 30;
		this.emitIntervalVariation 	= 30;
		
		this.baseColor 		= body.color;
	end;
	
	if onFire == 0 then
		await 1ms; // BUG? Necessario para o emit funcionar	
		emit fireEmitter.disable;
	end
	#endif


	// Loop funcional
	par/or do
		every dt in SDL_DT do	
			headDist = _BPT_moveInPath( character.player , &&node , (speed*dt) , (&&body.center.x) , (&&body.center.y) , minDist ) finalize with end;	
			effectArea.center = body.center;
		end
	#if USE_PARTICLES == 1	
	with
		loop do
			await this.disableFire;
			emit fireEmitter.disable;
			await this.enableFire;
			emit fireEmitter.enable;
		end
	#endif	
	with
		await this.destroy;
	end
	
	#if USE_PARTICLES == 1
	// Efeito visual da morte
	if onFire==1 then
		pool Flame[PARTICLES_PER_PLAYER_PARCEL*2] flamePool;
		pool Spark[PARTICLES_PER_PLAYER_PARCEL*2] dimSparkPool;
		pool Spark[PARTICLES_PER_PLAYER_PARCEL*2] brightSparkPool;
		
		var GEO_Area effectArea with
			this.type			= 3;
			this.center			= body.center;
			this.attribute1		= body.radius;
		end;
	
		var FireEmitter	fireEmitter with
			this.ren 				= &ren;
			this.windField			= &windField;
			this.emitterArea 		= &effectArea;
			this.flamePool 			= &flamePool;
			this.dimSparkPool 		= &dimSparkPool;
			this.brightSparkPool 	= &brightSparkPool;
				
			this.emitInterval 		= 1;
			this.emitIntervalVariation 	= 0;
		
			this.baseColor 		= body.color;
		end;	
		
		colision = 0;
		emit body.destroy;
	
		await 100ms;
		emit fireEmitter.disable;			
		await 2s;
	end
	#endif
end



// Boitata integra cabeça e corpo
class Boitata with
	var _SDL_Renderer& 	ren;
	var GEO_PolarPhysOrganism& 	character;
	var WindField&		windField;
	
	var GameData&		gameData;
	
	var	int&			headVelocity;
	var int				bodyVelocity	= 0;
	var int				targetSize		= 0;
	var int				actualSize		= 0;
	
	var int 			alive			= 1;
	var int				holdForm		= 1;
	
	var RGBA			foodColor		= RGBA(0,0,0,0);
	var int				colorStyle		= 0;	
	var int				bodyColorStyle	= _rand()%3;

	event void destroy;  
	event void unholdForm;
	
	pool BoitataBody[] bodies;
	pool Boitata[]& boitatas;
	
	pool Flame[PARTICLES_PER_PLAYER_PARCEL*6] 	flamePool;
	pool Spark[PARTICLES_PER_PLAYER_PARCEL*3] 	dimSparkPool;
	pool Spark[PARTICLES_PER_PLAYER_PARCEL*1] 	brightSparkPool;
	
	function (void)=>GEO_Circloid& getHeadCircloid;
do
	bodyVelocity = headVelocity;
	gameData.alivePlayers = gameData.alivePlayers + 1;
	
	// Cor
	if gameData.totalPlayers > 1 then
		// Multiplayer, cor fixa
		colorStyle = 0;
		if character.player == 0 then 
			foodColor = CORPLAYER1;
		else/if character.player == 1 then
			foodColor = CORPLAYER2;
		else
			foodColor = CORPLAYER3;
		end 
	else
		// Singleplayer, cor aleatoria
		var int ran = (_rand()%4 );
		if ran == 0 then
			foodColor = RGBA( 0xFF , 0xFF , 0xFF , 0x00 );	
			colorStyle = 1;
		else	
			colorStyle = 0;
			// Calculo da cor
			var int p1 , p2 , p3;
			var int[3] tColor = [0,0,0];
		
			ran = _rand()%3;
			p1 = ran;
		
			ran = _rand()%2;
			if ran==0 then
				p2 = (p1 + 1 + 3)%3;
				p3 = (p1 - 1 + 3)%3;
			else
				p2 = (p1 - 1 + 3)%3;
				p3 = (p1 + 1 + 3)%3;
			end;
		
			tColor[p1] = 255;
			tColor[p2] = (_rand()%255);
			tColor[p3] = (_rand()%(tColor[p2]/3));
		
			foodColor = RGBA( tColor[0] , tColor[1] , tColor[2] , 0x00 );	
		end
	end

	// Cabeça do boitata
	var BoitataHead boitataHead with
		this.ren 		= &ren;
		this.character 	= &character;
		this.color		= foodColor;
	end;		
	
	// Retorna geometria cabeça do boitata
	function (void)=>GEO_Circloid& getHeadCircloid do
		return &(boitataHead.getCircloid()); 
	end;	

	// Deletador de caminho: deleta nodes obsoletos do caminho
	var BoitataBody pathEraser with
		this.ren 		= &ren;	
		this.node 		= _BPT_getViceNode(character.player);
		this.speed 		= &bodyVelocity;	
		this.size		= 0;				
		this.minDist	= 100;
		this.character 			= &character;
		this.flamePool 			= &flamePool;
		this.dimSparkPool 		= &dimSparkPool;
		this.brightSparkPool 	= &brightSparkPool;
		this.onFire 	= 0;
		this.windField		= &windField;
	end;
		
	// Aguarda para formar o corpo
	if holdForm == 1 then
		await this.unholdForm;
	end
	
	// Cauda do boitata	
	var int i = 0;
	var BoitataBody[4] cauda with 
		i = i + 1;
		this.ren 		= &ren;	
		this.windField		= &windField;
		this.node 		= _BPT_getViceNode(character.player);
		this.speed 		= &bodyVelocity;	
		this.size		= 5 + ( i * 1 );				
		this.minDist	= 2 + ( (4-i) * 8 ) + (2*i);
		this.character 	= &character;
		this.flamePool 	= &flamePool;
		this.dimSparkPool 	= &dimSparkPool;
		this.brightSparkPool 	= &brightSparkPool;
		this.color		= foodColor;
		this.colorStyle	= bodyColorStyle;
	end;
	
	// Loop funcional
	par/or do
		var int flagDestroy = 0;
		every dt in SDL_DT do	
			// Deleta nodes obsoletos: depois do final da cauda
			_BPT_deleteUpTo( this.character.player , (pathEraser.node) );
			
			// Checa destruicao
			if flagDestroy == 1 then
				continue;
			end	
			
			// Ajusta velocidade do corpo a velocidade da cabeça
			bodyVelocity = headVelocity;
			
			// Cresce boitata
			if actualSize < targetSize then
				actualSize = actualSize + 1;
				var int segDist = 10;
				// Atualiza distancia minima da cauda
				loop i in 4 do
					cauda[i].minDist = cauda[i].minDist + segDist;
				end
				// Atualiza distancia minima do resto do corpo
				loop bo in bodies do
					bo:minDist = bo:minDist + segDist;
				end
				// Atualiza distancia minima do eraser
				pathEraser.minDist = pathEraser.minDist + segDist;
				
				// Cria novo corpo
				spawn BoitataBody in bodies with
					this.ren 			= &ren;	
					this.windField		= &windField;
					this.node 			= _BPT_getViceNode(character.player);
					this.speed 			= &bodyVelocity;
					this.size 			= 10;
					this.character 		= &character;
					this.flamePool 		= &flamePool;
					this.dimSparkPool 	= &dimSparkPool;
					this.brightSparkPool = &brightSparkPool;
					this.color			= foodColor;
					this.colorStyle		= bodyColorStyle;
					
					if actualSize%3 == 0 then
						this.darker = 1;
					end
				end;				
			end
		
			var _SDL_Rect& headRect = &(boitataHead.getCircloid().colisionBox);	
			// Checa colisao da cabeca com o resto do corpo	de todos os outros boitatas	
			var int tempPlayer = 0;
			var int tempAlive = 0;
			var float tempMinHeadDist = this.getHeadCircloid().radius * 3;
			loop btt in boitatas do
				tempPlayer = btt:character.player;		
				tempAlive = btt:alive;						
				loop bo in btt:bodies do
					// Caso: colisão com outros boitatas
					if tempPlayer != this.character.player then
						if tempAlive == 1 then
							if _SDL_HasIntersection( &&(bo:getCircloid().colisionBox) , &&(headRect) ) then
								flagDestroy = 1;
								break;
							end	
						end
					else
					// Caso: colisão com sigo mesmo
						if bo:headDist > tempMinHeadDist
						and  _SDL_HasIntersection( &&(bo:getCircloid().colisionBox) , &&(headRect) ) then
							flagDestroy = 1;
							break;
						end						
					end
				end
				
				if flagDestroy == 1 then
					break;
				end	
			end
			
			// Checa colisão da cabeca com os limites da tela
			// BUG! Esse AND do if é para corrigir um bug q ele sai logo na inicializacao
			if headRect.x < 0 or headRect.y < 0
			or ( (headRect.x + headRect.w) > (WIN_W / 1000) and (headRect.x + headRect.w) < (WIN_W / 1000)*1.1 )
			or ( (headRect.y + headRect.h) > (WIN_H / 1000) and (headRect.y + headRect.h) < (WIN_H / 1000)*1.1 )
			then
				flagDestroy = 1;
			end	
			
			// Checa destruicao
			if flagDestroy == 1 then
				emit this.destroy;
			end		
		end // Every End	
	with
		await 1s;
		await this.destroy;				
	end // Main Loop End
	
	// Destruição do organismo
	// Pára a cabeça
	boitataHead.character.velocityIntensity = 0;
	
	// Efeitos visuais da morte ( cabeca )
	emit boitataHead.dieFX;
	
	// Destroi Cauda
	loop i in 4 do
		emit cauda[i].destroy;
		await 70ms;
	end		
			
	// Destroi o corpo
	var BoitataBody&&?[] bds;
	loop bd in bodies do
			bds = []..bds..[bd];
	end		
	loop i in $bds do 
		if bds[i]? then
			emit bds[i]!:destroy;
		end
		await 70ms;
	end				
	
	// Destroi cabeça
	await 500ms;
	emit boitataHead.getCircloid().destroy;	
			
	// Declara como morto
	this.alive = 0;
	await 2s;
	gameData.alivePlayers = gameData.alivePlayers - 1;
	await 3s;
			
end



// Organismo que gerencia o Pathfinding dos caçadores
class Pathfinder with
	var _SDL_Renderer& 	ren;
	pool Boitata[]& boitatas;	
	
	var int	players = 1;
	
	// Retorna o endereco para uma estrutura de Path ou zero caso caminho nao encontrado
	function (int x1 , int y1 , int x2 , int y2)=>int getPath;
do
	// Cria Grid de Colisoes
	_AST_initGrid( PATH_CELLS_X , PATH_CELLS_Y , WIN_W/1000 , WIN_H/1000 );
	
	// Cria Lista de Caminhos
	_AST_initPathList(MAX_HUNTERS);
	
	// Cria Lista de posições da cabeça
	_AST_initHeadPositions( players );
	
	// Retorna o endereco para uma estrutura de Path ou zero caso caminho nao encontrado
	function (int x1 , int y1 , int x2 , int y2)=>int getPath do
		return 1;
	end	
	
	// Loop funcional
	par do
		// Dummy
	with
		loop do
			// Atualiza estado do grid de obstaculos
			await (GRID_UPDATE_INTERVAL)ms;
			
			// Zera o Grid
			_AST_zeroGrid();
			
			// Adiciona custo alto para andar nas bordas
			_AST_addCostLine( 10 , 0 , 10 , WIN_H/1000 , 30.0 );	
			_AST_addCostLine( WIN_W/1000 - 1 , 0 , WIN_W/1000 - 1 , WIN_H/1000 , 30.0 );	
			_AST_addCostLine( 0 , 10 ,  WIN_W/1000 , 10 , 30.0 );	
			_AST_addCostLine( 0 , WIN_H/1000 - 1 , WIN_W/1000 , WIN_H/1000 - 1 , 30.0 );	
			
			#if DEBUG_LV <= 2
			loop btt in boitatas do
				// Atualiza o Grid pela Posicao do Corpo
				loop bo in btt:bodies do
					if bo:colision == 1 then
						_AST_setGridStateFromCoords_Square( bo:getCircloid().center.x , bo:getCircloid().center.y , bo:getCircloid().radius , 1 );
					end
				end	
			
				// Atualiza o Grid pela Posicao da Cabeca
				_AST_setGridStateFromCoords_Circle( btt:getHeadCircloid().center.x , btt:getHeadCircloid().center.y , btt:getHeadCircloid().radius * 2 , 1 );
			
				// Aumenta o custo para passar perto da Cabeca
				_AST_addCostProximity( btt:getHeadCircloid().center.x , btt:getHeadCircloid().center.y , btt:getHeadCircloid().radius * 12 , 6.0 );	
				
				// Grava a posição da cabeça para os renzenvous
				_AST_setHeadPosition( btt:character.player , btt:getHeadCircloid().center.x , btt:getHeadCircloid().center.y , btt:alive );
			end	
			#endif
			
			#if DEBUG_LV == 3
			// Obstaculos Artificiais - Rigidos ( bloqueado ou não )
				_AST_setGridStateFromCoords_Circle( 99 , 150 , 100 , 1 );			
				_AST_setGridStateFromCoords_Line( 50 , 350 , 500 , 350 , 1 );
				_AST_setGridStateFromCoords_Line( 100 , 350 , 100 , 450 , 1 );
				_AST_setGridStateFromCoords_Line( 200 , 400 , 200 , 500 , 1 );	
				_AST_setGridStateFromCoords_Circle( 330 , 420 , 40 , 1 );	
			#endif
			
			#if DEBUG_LV == 4
			// Obstaculos Artificiais - Custo
				_AST_setGridStateFromCoords_Circle( 100 , 250 , 50 , 1 );
				_AST_setGridStateFromCoords_Circle( 250 , 100 , 50 , 1 );
				_AST_addCostProximity( 250 , 100 , 100 , 10.0 );
				_AST_setGridStateFromCoords_Circle( 250 , 250 , 50 , 1 );
				_AST_addCostProximity( 250 , 250 , 100 , 10.0 );		
			#endif		
			
			#if DEBUG_LV == 5
			// Obstaculos Artificiais - Custo
				_AST_setGridStateFromCoords_Circle( 400 , 100 , 50 , 1 );	
			#endif				
		end
	#if DEBUG_LV >= 2	
	// Desenha um caminho de teste
	with
		loop do
			await (PATH_UPDATE_INTERVAL)ms;
			_AST_findPath( 0 , 0 , 0 , 499 , 499 );		
		end
	with
	// Desenha o caminho de teste
		var int x1 = 0;
		var int y1 = 0;
		var int sx = _AST_getCellSize( 1 );
		var int sy = _AST_getCellSize( 2 );
		
		every SDL_REDRAW do		
			_SDL_SetRenderDrawColor(&&this.ren, 0xFF , 0xFF , 0x00 , 0 );
			var int size = _AST_TST_GetSize(0);	
			loop n in size do					
				_AST_TST_PathGetCoord( &&x1 , &&y1 , 0 , n ) finalize with end;
				_SDL_RenderDrawLine( &&this.ren ,  x1 , y1+(sy/2) , x1+sx , y1+(sy/2) );
				_SDL_RenderDrawLine( &&this.ren ,  x1+(sx/2) , y1 , x1+(sx/2) , y1+sy );
			end
		end
	#endif	
	#if DEBUG_LV >= 1
	// Desenha o GRID		
	with
		var int state = 0;
		var int x1 = 0;
		var int x2 = 0;
		var int y1 = 0;
		var int y2 = 0;
		var int sx = _AST_getCellSize( 1 );
		var int sy = _AST_getCellSize( 2 );
		
		every SDL_REDRAW do
			_SDL_SetRenderDrawColor(&&this.ren, 0xFF , 0xFF , 0xFF , 0 );
			// Espacos Ocupados 
			loop x in PATH_CELLS_X do
				loop y in PATH_CELLS_Y do
					state = _AST_getGridState( x , y );					
					if state == 1 then
						_AST_gridToCoord( &&x1 , &&y1 , x , y , 0) finalize with end;
						x2 = x1 + sx;
						y2 = y1 + sy;
						_SDL_RenderDrawLine( &&this.ren ,  x1 , y1 , x2 , y2 );
					end 
				end
			end  
			_SDL_SetRenderDrawColor(&&this.ren, 0xAA , 0xAA , 0xAA, 0 );
			// Marcacao X
			x1 = 0;
			y1 = 0;
			y2 = WIN_H / 1000;
			loop x in PATH_CELLS_X do
				_SDL_RenderDrawLine( &&this.ren ,  x1 , y1 , x1 , y2 );
				x1 = x1 + sx;
			end			
			// Marcacao Y
			y1 = 0;
			x1 = 0;
			x2 = WIN_W / 1000;
			loop y in PATH_CELLS_Y do
				_SDL_RenderDrawLine( &&this.ren ,  x1 , y1 , x2 , y1 );
				y1 = y1 + sy;
			end					 
		end
	#endif	
	end
	
end



// Caçador a ser caçado pelo boitata
class Hunter with
	var _SDL_Renderer& 	ren;	
	pool Boitata[]& 	boitatas;
	pool Hunter[]& 		hunters;
	var Pathfinder&		pathfinder;
	
	var GameData&		gameData;
	var WindField&		windField;
	
	var Vetor2D			startPos	= Vetor2D( (50 + (_rand()%((WIN_W/1000)-100)))*1000 , (50 + (_rand()%((WIN_H/1000)-100)))*1000 );	
	var int				value 		= (_rand()%100) + 50;
	var _SDL_Rect 		sensorBox	= _SDL_Rect( 0 , 0 , 0 , 0 );

	var int[]&			hunterSlots;	
	var int							cID			= 0; // IMPORTANTE: Usado pela estrutura em C
	
	event void decay; 
	event void destroy;    
	
	function (void)=>GEO_Circloid& getCircloid;
	
do
	var float speedScaleFactor = 0.5*(gameData.gameSpeed)/value;
	
	// Descobre um cID livre
	loop i in MAX_HUNTERS do
		if hunterSlots[i] == 0 then
			hunterSlots[i] = 1;
			cID = i;
			break;
		end
	end
		
	// Corpo fisico
	var GEO_PolarPhysOrganism hunterPO with
		this.velocityIntensity = speedScaleFactor * value;
		this.position = startPos;
		this.velocityDirection = 2.0 * PI * (_rand()%10000) / 10000;
	end;	
	
	// Corpo
	var GEO_Circloid hunter with
		this.ren = &ren;
		this.center = startPos;
		this.radius = 12;	
		
		// Calculo da cor
		var int ran;
		var int p1;
		var int p2;
		var int p3;
		var _int[3] tColor = [];
		
		ran = _rand()%3;
		p1 = ran;
		
		ran = _rand()%2;
		if ran==0 then
			p2 = (p1 + 1 + 3)%3;
			p3 = (p1 - 1 + 3)%3;
		else
			p2 = (p1 - 1 + 3)%3;
			p3 = (p1 + 1 + 3)%3;
		end;
		
		tColor[p1] = 255;
		tColor[p2] = 10 + (_rand()%245);
		tColor[p3] = 10 + (_rand()%(tColor[p2]/2));
		
		this.color = RGBA( tColor[0] , tColor[1] , tColor[2] , 0x00 );	
	end;
	var RGBA originalColor = hunter.color;
	
	// Colisor
	sensorBox.x = hunterPO.position.x;
	sensorBox.x = hunterPO.position.x;
	sensorBox.w = hunter.radius;
	sensorBox.h = hunter.radius;

	function (void)=>GEO_Circloid& getCircloid do
		return &(this.hunter); 
	end;

	// Olhos - Sclera
	var GEO_Circloid[2] olhosSclera with 
		this.ren = &ren;
		this.center = startPos;
		this.radius = 5;
		this.color = RGBA( 0xFF , 0xFF , 0xFF , 0x00 );
	end;	
	
	// Olhos - Iris
	var GEO_Circloid[2] olhosIris with 
		this.ren = &ren;
		this.center = startPos;
		this.radius = 3;
		this.color = RGBA( 0 , 0 , 0 , 0x00 );
	end;	
	
	// Variaveis internas
	var Vetor2D position = hunterPO.getPosition();
	var float colorScaleFactor = 1.0/value;
	var int energyLoss = 0;
	var int deathType = 0;

	// Variaveis do caminho
	var int pathIdx = 0;
	var int pathSiz = 0;
	
	// Loop funcional
	par/or do
		every dt in SDL_DT do
			position = hunterPO.getPosition();
		
			// Posicao da hunter		
			hunter.center.x = position.x;
			hunter.center.y = position.y;
		
			// Posicao dos olhos
			olhosSclera[0].center.x = position.x + ( _cos( hunterPO.velocityDirection + PI/4 ) * ( hunter.radius / 2 ) );
			olhosSclera[0].center.y = position.y + ( _sin( hunterPO.velocityDirection + PI/4 ) * ( hunter.radius / 2 ) );
			olhosSclera[1].center.x = position.x + ( _cos( hunterPO.velocityDirection - PI/4 ) * ( hunter.radius / 2 ) );
			olhosSclera[1].center.y = position.y + ( _sin( hunterPO.velocityDirection - PI/4 ) * ( hunter.radius / 2 ) );
				
			// Iris
			var int dx = _cos( hunterPO.velocityDirection ) * ( olhosSclera[0].radius - olhosIris[0].radius );
			var int dy = _sin( hunterPO.velocityDirection ) * ( olhosSclera[0].radius - olhosIris[0].radius );
			olhosIris[0].center.x = olhosSclera[0].center.x + dx; 
			olhosIris[1].center.x = olhosSclera[1].center.x + dx;
			olhosIris[0].center.y = olhosSclera[0].center.y + dy; 
			olhosIris[1].center.y = olhosSclera[1].center.y + dy;
						
			// Posicao do sensor
			sensorBox.x = position.x - (sensorBox.w/2) + ( _cos( hunterPO.velocityDirection ) * ( hunter.radius * 1.5 ) );
			sensorBox.y = position.y - (sensorBox.h/2) + ( _sin( hunterPO.velocityDirection ) * ( hunter.radius * 1.5 ) );
			
			// Colisão com as laterias
			if sensorBox.x < 0 then 
				hunterPO.velocityDirection = -(PI/2.0) + (0.1*PI) + (PI*0.01*(_rand()%80));
			else/if sensorBox.y < 0 then
				hunterPO.velocityDirection = (0.1*PI) + (PI*0.01*(_rand()%80));
			else/if (sensorBox.x + sensorBox.w ) > (WIN_W/1000) then
				hunterPO.velocityDirection = (PI/2.0) + (0.1*PI) + (PI*0.01*(_rand()%80));
			else/if (sensorBox.y + sensorBox.h ) > (WIN_H/1000) then
				hunterPO.velocityDirection = PI - (0.1*PI) + (PI*0.01*(_rand()%80));				
			end				
			
			// Colisão com a cabeça dos boitatas / GOL
			var int flagDestroy = 0;
			var int playerRef = 0;	
			var float difficultyBonus =  (gameData.difficulty+1/2.0);
			loop btt in boitatas do									
				if 	_SDL_HasIntersection( &&(hunter.colisionBox) , &&(btt:getHeadCircloid().colisionBox) ) then
					playerRef = btt:character.player;
					gameData.scoreHunters[playerRef] = gameData.scoreHunters[playerRef] + 1;	
					if value > 0 then
						// Comeu hunter bom
						gameData.scoreValues[playerRef] = gameData.scoreValues[playerRef] + ( difficultyBonus * ( ( ( 50 * ( gameData.alivePlayers - 1 ) ) + (  value  * gameData.alivePlayers * 2 ) ) ) );
						
						// Coloracao Especial
						if btt:colorStyle == 1 then
							if btt:actualSize < btt:targetSize then
								btt:foodColor.r = ( btt:foodColor.r + originalColor.r ) / 2;
								btt:foodColor.g = ( btt:foodColor.g + originalColor.g ) / 2;
								btt:foodColor.b = ( btt:foodColor.b + originalColor.b ) / 2;
							else
								btt:foodColor = originalColor;
							end
						end
						btt:targetSize = btt:targetSize + 3;
					else
						// Comeu hunter estragado
						gameData.scoreValues[playerRef] = gameData.scoreValues[playerRef] + ( difficultyBonus * ( value * ( gameData.totalPlayers - gameData.alivePlayers + 1 ) * 4 ) );
					end
					flagDestroy = 1;
					break;
				end	
			end			
			
			if flagDestroy == 1 then
				deathType = 1;
				emit this.destroy;
			end
			
			// Colisão com o corpo dos boitatas
			loop btt in boitatas do			
				loop bo in btt:bodies do
					if bo:minDist > 30
					and _SDL_HasIntersection( &&(bo:getCircloid().colisionBox) , &&(sensorBox) ) then
						hunterPO.velocityDirection = hunterPO.velocityDirection + PI;
					end
				end	
			end	
			
			// Colisão com outros hunters
			// TODO: Segmentation Fault ( as vezes ), entender o pq...
			/*
			loop hun in hunters do			
				if &&(hun:getCircloid().colisionBox) != &&(hunter.colisionBox)
				and _SDL_HasIntersection( &&(hun:getCircloid().colisionBox) , &&(sensorBox) ) then
					hunterPO.velocityDirection = hunterPO.velocityDirection + ((_rand()%2)*(PI/3));
				end
			end	
			*/
			
			// Transformar hunter em obstaculo para outros hunters
			_AST_setGridStateFromCoords( hunter.center.x , hunter.center.y , 1 );
			_AST_addCostProximity( hunter.center.x , hunter.center.y , hunter.radius * 4 , 15.0 );
				
		end
	with
		// Diminui pontuacao
		var float colorFactor = 0;
		every 1000ms do
			value = value - energyLoss;
			if value > 0 then
				colorFactor = value * colorScaleFactor;
				if colorFactor > 1.0 then colorFactor = 1.0;
				else/if colorFactor < 0 then colorFactor = 0; end
				hunter.color.r = hunter.color.r * colorFactor;
				hunter.color.g = hunter.color.g * colorFactor;
				hunter.color.b = hunter.color.b * colorFactor;			 
			else
				value = -100;
				hunter.color.r = 0;
				hunter.color.g = 0;
				hunter.color.b = 0;
				hunterPO.velocityIntensity = 0;
				olhosIris[0].color = RGBA( 0xFF , 0xFF , 0xFF , 0 );
				olhosIris[1].color = RGBA( 0xFF , 0xFF , 0xFF , 0 );
				emit this.decay;
			end
			
		end
	with
		// Comportamento do Hunter
		var int dx = 0;
		var int dy = 0;
		var int dist = 0;
		var float runDir = 0;
		
		loop do
			// Destroi caminho existente, caso exista
			_AST_destroyPath( cID );
				
			// Etapa 01: Fica vagando até o boitata chegar perto
			par/or do
				// Direcao
				every (_rand()%1000)ms do
					// Fica vagando
					hunterPO.angularVelocity = -0.005 + (0.001*(_rand()%10));	
				end	
			with
				// Desacelera
				var float tempRunFactor = 0;
				if energyLoss > 0 then
					tempRunFactor = (gameData.enemySpeedScale);
					energyLoss = 0;
					
					loop do
						tempRunFactor = tempRunFactor - 0.1;				
						if value > 0 then
							hunterPO.velocityIntensity = speedScaleFactor * value * tempRunFactor; end		
						if tempRunFactor <= 0.3 then
							break; end		
						await (100)ms;			
					end
					
					await FOREVER;
				end
			with
				// Checa proximidade com boitata
				loop do
					await 100ms;
					var int breakFlag = 0;
					loop btt in boitatas do
						dx = (hunterPO.position.x - btt:character.position.x)/1000;
						dy = (hunterPO.position.y - btt:character.position.y)/1000;			
						dist = _sqrt( _pow( dx , 2 ) + _pow( dy , 2 ) );
						
						if dist < 150  then
							if breakFlag == 0 then
								breakFlag = 1;
								runDir = _MPT_getDirection(0,0,dx,dy);
							else
								runDir = runDir + _MPT_getDirection(0,0,dx,dy) / 2;
							end
						end
						
					end
					if breakFlag == 1 then
						break;
					end
				end
			end // Fim da Etapa 01
			
			// Etapa 02: Boitata esta proximo, fugir!
			#if DEBUG_LV > 0
				_printf("\nDEBUG: Fugindo do boitata!\n");
			#endif
			par/or do
				energyLoss = 10;
				
				if value > 0 then
					hunterPO.velocityIntensity = speedScaleFactor * value * (gameData.enemySpeedScale); end
				
				// Checa se todos os boitatas ja foram para longe. Caso sim, terminar a etapa 02
				loop do	
					await 100ms;
					var int breakFlag = 1;
					loop btt in boitatas do
						dx = (hunterPO.position.x - btt:character.position.x)/1000;
						dy = (hunterPO.position.y - btt:character.position.y)/1000;			
						dist = _sqrt( _pow( dx , 2 ) + _pow( dy , 2 ) );
						
						if dist < 150  then
							if breakFlag == 1 then
								breakFlag = 0;
								runDir = _MPT_getDirection(0,0,dx,dy);
							else
								runDir = runDir + _MPT_getDirection(0,0,dx,dy) / 2;
							end
						end						
					end
					if breakFlag == 1 then
						#if DEBUG_LV > 0
							_printf("\nDEBUG: Voltando a vagar!\n");
						#endif
						break;
					end	
				end							
			with
				// Decide como fugir			
				loop do
					// Atualiza o comportamento a cada RENDEZVOUS_UPDATE_INTERVAL ms
					par/or do
						await (RENDEZVOUS_UPDATE_INTERVAL)ms;
					with						
						// Destroi caminho existente, caso exista
						_AST_destroyPath( cID );
												
						// Localizando um ponto destino para fugir ( rendezvous )
						var int xDest = -1;
						var int yDest = -1;	
						var int px = hunterPO.position.x/1000;
						var int py = hunterPO.position.y/1000;
						var int dodgeLevel = 0;
						
						// Detecta possibilidade de esquivar do boitata de acordo com a distancia
						var int minHeadDist = _MPT_minHeadDistance( px , py );
						if minHeadDist < 100 then
							var float chance = ( 100.0 - minHeadDist ) * 0.8;
							if (_rand()%100 ) < chance then
								dodgeLevel = 2 + (_rand()%5);
							end
						end
						
						// Encontra ponto de fuga
						_MPT_getClearPoint( &&xDest , &&yDest , px , py , 200 , runDir , 5.0 , dodgeLevel ) finalize with end; 
						
						// Localizando uma rota de fuga para o rendezvous
						loop do
							// Localizando uma rota de fuga para o rendezvous
							pathSiz = 0;
							px = hunterPO.position.x/1000;
							py = hunterPO.position.y/1000;
							if xDest >=0 then
								#if USE_THREAD == 1	
								async/thread ( px , py , xDest , yDest , cID , pathSiz ) do	
								    atomic do				
									    _AST_findPath( cID , px , py , xDest , yDest );	
									    pathSiz = _AST_getPathSize( cID );		
                                    end									
								end
								#else
								async ( px , py , xDest , yDest , cID , pathSiz ) do				
									_AST_findPath( cID ,px , py , xDest , yDest );
									pathSiz = _AST_getPathSize( cID );
								end
								#endif
							end
	
							// Descobre se o caminho é mt curto ou se não encontrou caminho
							if pathSiz < 5 then
								// Caso não encontre caminho, apenas fuja na direção oposta do inimigo
								if pathSiz == 0 then
									var float iDir = ( runDir - hunterPO.velocityDirection ) / 5;
									loop do
										if _abs( runDir - hunterPO.velocityDirection ) < iDir then
											break; end
										hunterPO.velocityDirection = hunterPO.velocityDirection + iDir;
										await 30ms;
									end	
									hunterPO.velocityDirection = runDir;								
								else
								// Caminho muito curto, terminar trilha ( achar outro randezvous )
									break;
								end
							else
								// Fugir pelo caminho encontrado
								par/or do
									// Caso encontre, fugir pelo caminho encontrado
									var int retr = 0;
									var float dir = 0;
									pathIdx = 5;
						
									loop do
										if pathIdx >= ( pathSiz - 2 ) then
											break;
										end;
														
										px = hunterPO.position.x/1000;
										py = hunterPO.position.y/1000;

										retr = _MPT_nextDirection( &&dir , px , py , cID , pathIdx ) finalize with end;
										if retr == 1 then
											hunterPO.velocityDirection = dir;
										else
											pathIdx = pathIdx + 1;
										end	

										await 30ms;	
									end	
								with		
									// Aguarda a proxima tentativa
									await (PATH_UPDATE_INTERVAL)ms;	
								end			
							end		
							
							// Checa se o boitata está proximo demais
							if _MPT_minHeadDistance( px , py ) < 100 then
								break;
							end						
							
							// Checa se o rendezvous ficou muito caro / ruim / inacessivel
							if _MPT_isPointBest( px , py , xDest , yDest , 5.0 ) < 2 then
								break;
							end
						end // Loop de encontrar caminho para o rendezvous
					end
				end
			end // Fim da Etapa 02
		end
	#if DEBUG_LV >= 1
	with
	// Desenha o caminho do bicho
		var int x1 = 0;
		var int y1 = 0;
		var int sx = _AST_getCellSize( 1 );
		var int sy = _AST_getCellSize( 2 );
		
		every SDL_REDRAW do
			_SDL_SetRenderDrawColor(&&this.ren, 0xFF , 0xFF , 0x00 , 0 );
			var int size = _AST_TST_GetSize(cID);	
			loop n in size do					
				_AST_TST_PathGetCoord( &&x1 , &&y1 , cID , n ) finalize with end;
				_SDL_RenderDrawLine( &&this.ren ,  x1 , y1+(sy/2) , x1+sx , y1+(sy/2) );
				_SDL_RenderDrawLine( &&this.ren ,  x1+(sx/2) , y1 , x1+(sx/2) , y1+sy );
			end
		end
	#endif	
	with
		await decay;	
		await 2s;
		deathType = 0;
	with
		await destroy;			
	end	
	
	// Libera memoria do caminho
	_AST_destroyPath( cID );
	hunterSlots[cID] = 0;
	
	#if USE_PARTICLES == 1
	// Efeito visual da morte
	if deathType==1 then
		pool Flame[PARTICLES_PER_ENEMY_PARCEL*5] flamePool;
		pool Spark[PARTICLES_PER_ENEMY_PARCEL*5] dimSparkPool;
		pool Spark[PARTICLES_PER_ENEMY_PARCEL*5] brightSparkPool;
		
		var GEO_Area effectArea with
			this.type			= 3;
			this.center			= hunter.center;
			this.attribute1		= hunter.radius;
		end;
	
		var FireEmitter	fireEmitter with
			this.ren 				= &ren;
			this.windField			= &windField;
			this.emitterArea 		= &effectArea;
			this.flamePool 			= &flamePool;
			this.dimSparkPool 		= &dimSparkPool;
			this.brightSparkPool 	= &brightSparkPool;
				
			this.emitInterval 	= 3;
			this.emitIntervalVariation 	= 0;
		
			if value > 0 then
				this.baseColor 		= originalColor;
			else
				this.baseColor 		= hunter.color;
			end
		end;	
	
		emit hunter.destroy;
		emit olhosSclera[0].destroy;
		emit olhosSclera[1].destroy;
		emit olhosIris[0].destroy;
		emit olhosIris[1].destroy;
	
		await 500ms;
		emit fireEmitter.disable;			
		await 2s;
	end
	#endif
end


// --------------------------------------------------------------------------------

// Selecao


// Loop Principal do Jogo
_srand(_time(null));

par/or do
    await SDL_QUIT;
with
    every SDL_REDRAW do
        _SDL_SetRenderDrawColor(&&renderer!,0x00,0x00,0x00,0x00);
        _SDL_RenderFillRect(&&renderer!, null);
    end
with
    // Dados tecnicos
    var FrameCounter frameCounter;
    
    #if USER_INTERFACE == 1
    // UI de configurações do jogo
    do
		var SCR_staticText title with
			this.ren 			= &renderer!;
			this.text 			= "Boitata";
			this.fontSize		= 40;
			this.x				= WIN_W/1000/2;
			this.y				= 20;
			this.xAlign			= 0; 
			this.yAlign			= 1;
		end;
		
		var SCR_staticText labelPlayersTitle with
			this.ren 			= &renderer!;
			this.text 			= "Quantidade de Jogadores";
			this.fontSize		= 30;
			this.x				= WIN_W/1000/2;
			this.y				= 100;
			this.xAlign			= 0; 
			this.yAlign			= 1;			
		end;
		
		// Menu 1 : Selecao de quantidade de jogadores
		var SCR_staticText labelPlayersTitle with
			this.ren 			= &renderer!;
			this.text 			= "Quantidade de Jogadores";
			this.fontSize		= 30;
			this.x				= WIN_W/1000/2;
			this.y				= 100;
			this.xAlign			= 0; 
			this.yAlign			= 1;			
		end;		
		
		var SDL_Color unselectedColor = SDL_Color( 0xAA , 0xAA , 0xAA , 0xFF );
		var SDL_Color selectedColor = SDL_Color( 0xFF , 0x00 , 0x00 , 0xFF );
				
		var int xParcel = WIN_W / 1000 / 4;
		var int tx = 0;
		var int ty = labelPlayersTitle.y + 40;
		
		var SCR_text[3] playerLabels with
			this.ren 			= &renderer!;
		end;
		loop i in 3 do
			tx = tx + xParcel;
			playerLabels[i].init( _SRC_intToString(i+1) , "../Font.ttf" , 30 , unselectedColor , tx , ty , 0 , 1 );	
		end
		
		playerLabels[0].setFontColor(selectedColor);
	
		// Menu 2 : Selecao de nivel de dificuldade
		var SCR_staticText labelDiffTitle with
			this.ren 			= &renderer!;
			this.text 			= "Dificuldade";
			this.fontSize		= 30;
			this.x				= WIN_W/1000/2;
			this.y				= 240;
			this.xAlign			= 0; 
			this.yAlign			= 1;			
		end;		
		
		unselectedColor = SDL_Color( 0xAA , 0xAA , 0xAA , 0xFF );
		selectedColor = SDL_Color( 0xFF , 0x00 , 0x00 , 0xFF );
				
		xParcel = WIN_W / 1000 / 11;
		tx = 0;
		ty = labelDiffTitle.y + 40;
		
		var SCR_text[10] diffLabels with
			this.ren 			= &renderer!;
		end;
		loop i in 10 do
			tx = tx + xParcel;
			diffLabels[i].init( _SRC_intToString(i+1) , "../Font.ttf" , 30 , unselectedColor , tx , ty , 0 , 1 );	
		end
		
		// Seleção dos menus
		// Etapa 1: Quantidade de jogadores
		do
			var MenuControls menuControls with
				this.maxOptions = 3;
				this.circle = 1;
			end;
			par/or do
				loop do
					var int selected = menuControls.selected;
					await menuControls.changed;
					playerLabels[selected].setFontColor(unselectedColor);
					selected = menuControls.selected;
					playerLabels[selected].setFontColor(selectedColor);
				end
			with
				await menuControls.confirmed;	
			end
			tempPlayerQTD = menuControls.selected + 1;
		end
		
		
		// Etapa 2: Dificuldade
		do
			var MenuControls menuControls with
				this.maxOptions = 10;
				this.circle = 1;
			end;
			diffLabels[0].setFontColor(selectedColor);
			par/or do
				loop do
					var int selected = menuControls.selected;
					await menuControls.changed;
					diffLabels[selected].setFontColor(unselectedColor);
					selected = menuControls.selected;
					diffLabels[selected].setFontColor(selectedColor);
				end
			with
				await menuControls.confirmed;	
			end
			tempDifficuty = menuControls.selected + 1;
		end	
	end    
	#endif
	
	// Loop de partidas
	loop do
		gameSet = gameSet + 1;
	
		// Configuracoes basicas do jogo
		var int[4] scoreValues 	= [0,0,0,0];
		var int[4] scoreHunters = [0,0,0,0];	
		var GameData gameData with
			this.scoreHunters 	= &scoreHunters; 
			this.scoreValues 	= &scoreValues;	
			this.totalPlayers 	= tempPlayerQTD;
			this.alivePlayers 	= 0;
			this.difficulty 	= tempDifficuty;				
		end;
		
		// Controlador do vento
		var WindField windField;
	
		// Pools de boitatas
		pool Boitata[] boitatas;
		pool PlayerControls[] playerCONs;
	
		// TODO: Melhorar com um loop -> nao sei fazer com o loop, problema de escopo.
		var float createPos_dir 	= ( (_rand()%((int)PI*2000))/1000.0 );
		var float createPos_inc		= (PI*2) / gameData.totalPlayers;
		var int   createPos_les		= WIN_H/4;
		if WIN_W < WIN_H then
			createPos_les = WIN_H/4;
		end
		
			// Cria Jogador 1
				createPos_dir = createPos_dir + createPos_inc;
				var GEO_PolarPhysOrganism playerPO_1 with
					this.position 			= Vetor2D( WIN_W/2 + (_cos(createPos_dir)*createPos_les) , WIN_H/2 + (_sin(createPos_dir)*createPos_les) );
					this.velocityDirection 	= createPos_dir + (PI/2);
					this.velocityIntensity 	= gameData.gameSpeed;
					this.player 			= 0;
				end;
			
				// Inicializa estrutura do caminho
				_BPT_init( playerPO_1.player , playerPO_1.position.x/1000 , playerPO_1.position.y/1000 );
				finalize with
					_BPT_destroi(playerPO_1.player);
				end;		
				_BPT_addViceNode(playerPO_1.player);	
				
				
				if gameData.totalPlayers >= 1 then			
					// Organismo dos controles do jogador
					spawn PlayerControls in playerCONs with
						this.character 	= &playerPO_1;
						this.player 	= playerPO_1.player;
					end;

					// Personagem
					spawn Boitata in boitatas with
						this.ren 			= &renderer!;	
						this.character 		= &playerPO_1;
						this.boitatas 		= &boitatas;
						this.headVelocity 	= &(playerPO_1.velocityIntensity);
						this.windField		= &windField;
						this.gameData		= &gameData;
					end;		
				else
					emit playerPO_1.destroy;
				end
			
			
			
			// Cria Jogador 2
				createPos_dir = createPos_dir + createPos_inc;
				var GEO_PolarPhysOrganism playerPO_2 with
					this.position 			= Vetor2D( WIN_W/2 + (_cos(createPos_dir)*createPos_les) , WIN_H/2 + (_sin(createPos_dir)*createPos_les) );
					this.velocityDirection 	= createPos_dir + (PI/2);
					this.velocityIntensity 	= gameData.gameSpeed;
					this.player 			= 1;
				end;
	
			
				// Inicializa estrutura do caminho
				_BPT_init( playerPO_2.player , playerPO_2.position.x/1000 , playerPO_2.position.y/1000 );
				finalize with
					_BPT_destroi(playerPO_2.player);
				end;		
				_BPT_addViceNode(playerPO_2.player);	
				
				
				if gameData.totalPlayers >= 2 then			
					// Organismo dos controles do jogador
					spawn PlayerControls in playerCONs with
						this.character 	= &playerPO_2;
						this.player 	= playerPO_2.player;
					end;

					// Personagem
					spawn Boitata in boitatas with
						this.ren 			= &renderer!;	
						this.character 		= &playerPO_2;
						this.boitatas 		= &boitatas;
						this.headVelocity 	= &(playerPO_2.velocityIntensity);
						this.windField		= &windField;
						this.gameData		= &gameData;
					end;		
				else
					emit playerPO_2.destroy;
				end


			// Cria Jogador 3
				createPos_dir = createPos_dir + createPos_inc;
				var GEO_PolarPhysOrganism playerPO_3 with
					this.position 			= Vetor2D( WIN_W/2 + (_cos(createPos_dir)*createPos_les) , WIN_H/2 + (_sin(createPos_dir)*createPos_les) );
					this.velocityDirection 	= createPos_dir + (PI/2);
					this.velocityIntensity 	= gameData.gameSpeed;
					this.player 			= 2;
				end;
	
			
				// Inicializa estrutura do caminho
				_BPT_init( playerPO_3.player , playerPO_3.position.x/1000 , playerPO_3.position.y/1000 );
				finalize with
					_BPT_destroi(playerPO_3.player);
				end;		
				_BPT_addViceNode(playerPO_3.player);	
				
				
				if gameData.totalPlayers >= 3 then			
					// Organismo dos controles do jogador
					spawn PlayerControls in playerCONs with
						this.character 		= &playerPO_3;
						this.player 		= playerPO_3.player;
					end;

					// Personagem
					spawn Boitata in boitatas with
						this.ren 			= &renderer!;	
						this.character 		= &playerPO_3;
						this.boitatas 		= &boitatas;
						this.headVelocity 	= &(playerPO_3.velocityIntensity);
						this.windField		= &windField;
						this.gameData		= &gameData;
					end;		
				else
					emit playerPO_3.destroy;
				end	
	
		// Inicializa Estrutura do AStar
		var Pathfinder pathfinder with
			this.ren 		= &renderer!;	
			this.boitatas 	= &boitatas;
			this.players 	= gameData.totalPlayers;
		end;		

		// Aguarda uma tecla direcional para começar o jogo
		do
			var AwaitForConfirm allConfirm with
				this.playerCONs				= &playerCONs;
				this.disableUntilConfirm 	= 1;
			end;
		
			await 1ms; // Necessário para o passo seguinte
			var Boitata&&?[] btts;
			loop btt in boitatas do
				btts = []..btts..[btt];
			end	

			loop i in $btts do 
				if btts[i]? then
					btts[i]!:character.velocityIntensity = gameData.gameSpeed/4;
					btts[i]!:character.angularVelocity = ( (gameData.gameSpeed/4.0/1000) / 30.0  );
				end
			end	
										
			// Libera a criação do corpo dos boitatas conforme os jogadores vão confirmando					
			par/or do
				loop do
					await SDL_DT;
					loop i in $allConfirm.confirmedPlayers do
						if allConfirm.confirmedPlayers[i] == 1 then
							emit btts[i]!:unholdForm;
						end	
					end
				end
			with
				await allConfirm.allConfirmed;
			end		
			
			// Libera a criação do corpo de todos os boitatas ( redundancia ao loop anterior )
			loop i in $btts do 
				if btts[i]? then
					emit btts[i]!:unholdForm;
				end
			end	
			
			// Contagem regressiva para iniciar o jogo
			var float counter = 2.0;		
			var SDL_Color tColor = SDL_Color(0xFF,0xFF,0xFF,0xFF);
			var SCR_text counterDisplay	= SCR_text.build( &renderer! , " " , "../Font.ttf" , 40 , tColor , WIN_W/2000 , WIN_H/2000 , 0 , 0 );
			loop do
				await 10ms;
				if counter <= 0 then
					break;
				end
				counter = counter - 0.010;
				
				// Atualiza o Contador
				counterDisplay.setText(_SRC_floatToString(counter) );
				counterDisplay.setFontSize( (int)(counter*10 + 10) );	
				
				// Aumenta gradativamente velocidade dos boitatas
				loop i in $btts do 
					if btts[i]? then
						btts[i]!:character.velocityIntensity = gameData.gameSpeed / ( 1.0 + ( counter*1.5 ) );
						btts[i]!:character.angularVelocity = ( ( btts[i]!:character.velocityIntensity / 1000.0 ) / 30.0  );
					end
				end	
			end
		
			// Destroi o allConfirm ( automaticamente libera controle aos jogadores )
			emit allConfirm.destroy;
		
			// Seta as configuracoes dos boitatas
			loop i in $btts do 
				if btts[i]? then
					btts[i]!:character.velocityIntensity = gameData.gameSpeed;
					btts[i]!:character.angularVelocity = 0;
				end
			end	
		end	

		//Ciclo de jogo	
		par/or do
			// Para o ciclo caso todos os boitatas sejam destruidos
			loop do
				await 500ms;
				if gameData.alivePlayers < 1 then
					break;
				end				
			end 
		with
			// Controle de nascimento dos hunters
			pool Hunter[MAX_HUNTERS] hunters;
			var int tt = 0;
			var int[] hunterSlots;	
			loop i in MAX_HUNTERS do
				hunterSlots = []..hunterSlots..[0];
			end
			
			
			loop do
				// Varia Starting Point para nascer longe do boitata
				var Vetor2D		startPos = Vetor2D( 0 , 0 );
				var int tDx = 0;
				var int tDy = 0;
				var int tDist = 0;
				startPos	= Vetor2D( (50 + (_rand()%((WIN_W/1000)-100)))*1000 , (50 + (_rand()%((WIN_H/1000)-100)))*1000 );
				loop do
				
					if _MPT_minHeadDistance( startPos.x , startPos.y ) > 200 then
						break;
					end 
					
					startPos.x = startPos.x + 50;
					startPos.y = startPos.y + 50;
					
					if startPos.x < 50 then startPos.x = (WIN_W/1000) - 50;
					else/if startPos.x > ((WIN_W/1000) - 50) then startPos.x = 50; end
					
					if startPos.y < 50 then startPos.y = (WIN_H/1000) - 50;
					else/if startPos.y > ((WIN_H/1000) - 50) then startPos.y = 50; end					
							
					await 10ms;
				end		
				
				#if DEBUG_LV <= 1
					spawn Hunter in hunters with
						this.boitatas 		= &boitatas;
						this.gameData		= &gameData;
						this.windField		= &windField;
						this.hunters 		= &hunters;
						this.pathfinder 	= &pathfinder;
						this.ren 			= &renderer!;
						this.startPos 		= startPos;
						this.hunterSlots	= &hunterSlots;
					end;
				#endif	
				
				await (1000 + (_rand()%3000))ms;	
			end	
		end
	
		// Exibe pontuação final da partida
		var int vencedor = 0;
		_printf("\n[[[ FIM DA PARTIDA %d ]]]\n",gameSet);
		loop n in gameData.totalPlayers do
			if n == 0 then
				if gameData.totalPlayers > 1 then
					_printf("\n\tJogador 1 ( vermelho ):\n");
				else
					_printf("\n\tJogador 1:\n");
				end
			else/if n == 1 then 
				_printf("\n\tJogador 2 ( azul ):\n");
			else
				_printf("\n\tJogador 3 ( verde ):\n");
			end
		
			if scoreValues[n] > scoreValues[vencedor] then
				vencedor = n;
			end
	
			_printf("\t\tPontuacao Final: \t%d\n",scoreValues[n]);
			_printf("\t\tCacadores Devorados: \t%d\n",scoreHunters[n]);
		end
		_printf("\nVENCEDOR DA PARTIDA %d: JOGADOR %d\n",gameSet,(vencedor+1));

		// Grava total de pontos no placar persistente
		loop n in 4 do
			totalScoreValues[n] = totalScoreValues[n] + scoreValues[n];
			totalScoreHunters[n] = totalScoreHunters[n] + scoreHunters[n];
		end

		// Exibe pontuação geral
		var int vencedor = 0;
		_printf("\n[[[ PLACAR GERAL ]]]]");
		loop n in gameData.totalPlayers do
			if n == 0 then
				_printf("\n\tJogador 1:\tPontos: %d",totalScoreValues[n]);
			else/if n == 1 then 
				_printf("\n\tJogador 2:\tPontos: %d",totalScoreValues[n]);
			else
				_printf("\n\tJogador 3:\tPontos: %d",totalScoreValues[n]);
			end
		
			if totalScoreValues[n] > totalScoreValues[vencedor] then
				vencedor = n;
			end
		end
		_printf("\n\tLIDER: JOGADOR %d\n",(vencedor+1));
		
		#if USER_INTERFACE == 1
		// Exibe o placar em tela
		var int bx = 0;
		var int by = 20;
		var int xParcel = WIN_W/1000/10;
		var int tx = 0;
		var int ty = 70;
		var int tFontSize = 15;
		
				
		var SCR_staticText title with
			this.ren 			= &renderer!;
			this.text 			= "Partida: ";
			this.fontSize		= 30;
			this.x				= xParcel*6;
			this.y				= by;
			this.xAlign			= -1; 
			this.yAlign			= 1;
		end;

		var SCR_text gameSetCounter = SCR_text.build( &renderer! , _SRC_intToString(gameSet) , "../Font.ttf" , 30 , title.fontColor , title.x , title.y , 1 , 1 );	
		
		bx = 0;
		ty = 50;
		xParcel = ( (WIN_W/1000) - bx ) / 9;
		var int[4] px;
		px = []..px..[bx + ( xParcel * 1.0 )];
		px = []..px..[bx + ( xParcel * 2.7 )];
		px = []..px..[bx + ( xParcel * 4.5 )];
		px = []..px..[bx + ( xParcel * 7.0 )];
		
		var SCR_staticText headerJogador with
			this.ren 			= &renderer!;
			this.text 			= "Jogador";
			this.fontSize		= tFontSize;
			this.x				= px[0];
			this.y				= title.y + ty;
			this.xAlign			= 0; 
			this.yAlign			= 1;
		end;
		
		var SCR_staticText headerHunters1 with
			this.ren 			= &renderer!;
			this.text 			= "Inimigos";
			this.fontSize		= tFontSize;
			this.x				= px[1];
			this.y				= title.y + ty;
			this.xAlign			= 0; 
			this.yAlign			= 1;
		end;					
		var SCR_staticText headerHunters2 with
			this.ren 			= &renderer!;
			this.text 			= "Devorados";
			this.fontSize		= tFontSize;
			this.x				= headerHunters1.x;
			this.y				= headerHunters1.y + 20;
			this.xAlign			= 0; 
			this.yAlign			= 1;
		end;
		
		var SCR_staticText headerPontuacao with
			this.ren 			= &renderer!;
			this.text 			= "Pontos";
			this.fontSize		= tFontSize + 5;
			this.x				= bx + ( xParcel * 5.75 );
			this.y				= title.y + ty;
			this.xAlign			= 0; 
			this.yAlign			= 1;
		end;
		var SCR_staticText headerPontuacaoPartida1 with
			this.ren 			= &renderer!;
			this.text 			= "Partida";
			this.fontSize		= tFontSize;
			this.x				= px[2];
			this.y				= headerPontuacao.y + 20;
			this.xAlign			= 0; 
			this.yAlign			= 1;
		end;
							
		var SCR_staticText headerPontuacaoTotal1 with
			this.ren 			= &renderer!;
			this.text 			= "Totais";
			this.fontSize		= tFontSize;
			this.x				= px[3];
			this.y				= headerPontuacao.y + 20;
			this.xAlign			= 0; 
			this.yAlign			= 1;
		end;	
			
			
		ty = 80;		
		by = headerJogador.y + 10;
		tFontSize = tFontSize + 5;	
		
		
		var SCR_text p1_id 		= SCR_text.build( &renderer! , " " , "../Font.ttf" , tFontSize , title.fontColor , px[0] , by+(ty*1) , 0 , 1 );	
		var SCR_text p1_hunters = SCR_text.build( &renderer! , " " , "../Font.ttf" , tFontSize , title.fontColor , px[1] , by+(ty*1) , 0 , 1 );
		var SCR_text p1_pts 	= SCR_text.build( &renderer! , " " , "../Font.ttf" , tFontSize , title.fontColor , px[2] , by+(ty*1) , 0 , 1 );
		var SCR_text p1_total 	= SCR_text.build( &renderer! , " " , "../Font.ttf" , tFontSize , title.fontColor , px[3] , by+(ty*1) , 0 , 1 );	
		if gameData.totalPlayers >= 1 then
			p1_id.setText(_SRC_intToString(gameSet) );	
			p1_hunters.setText(_SRC_intToString(scoreHunters[0]) );	
			p1_pts.setText(_SRC_intToString(scoreValues[0]) );	
			p1_total.setText(_SRC_intToString(totalScoreValues[0]) );				
		end


		var SCR_text p2_id 		= SCR_text.build( &renderer! , " " , "../Font.ttf" , tFontSize , title.fontColor , px[0] , by+(ty*2) , 0 , 1 );	
		var SCR_text p2_hunters = SCR_text.build( &renderer! , " " , "../Font.ttf" , tFontSize , title.fontColor , px[1] , by+(ty*2) , 0 , 1 );
		var SCR_text p2_pts 	= SCR_text.build( &renderer! , " " , "../Font.ttf" , tFontSize , title.fontColor , px[2] , by+(ty*2) , 0 , 1 );
		var SCR_text p2_total 	= SCR_text.build( &renderer! , " " , "../Font.ttf" , tFontSize , title.fontColor , px[3] , by+(ty*2) , 0 , 1 );	
		if gameData.totalPlayers >= 2 then
			p2_id.setText(_SRC_intToString(gameSet) );	
			p2_hunters.setText(_SRC_intToString(scoreHunters[1]) );	
			p2_pts.setText(_SRC_intToString(scoreValues[1]) );	
			p2_total.setText(_SRC_intToString(totalScoreValues[1]) );				
		end		


		var SCR_text p3_id 		= SCR_text.build( &renderer! , " " , "../Font.ttf" , tFontSize , title.fontColor , px[0] , by+(ty*3) , 0 , 1 );	
		var SCR_text p3_hunters = SCR_text.build( &renderer! , " " , "../Font.ttf" , tFontSize , title.fontColor , px[1] , by+(ty*3) , 0 , 1 );
		var SCR_text p3_pts 	= SCR_text.build( &renderer! , " " , "../Font.ttf" , tFontSize , title.fontColor , px[2] , by+(ty*3) , 0 , 1 );
		var SCR_text p3_total 	= SCR_text.build( &renderer! , " " , "../Font.ttf" , tFontSize , title.fontColor , px[3] , by+(ty*3) , 0 , 1 );	
		if gameData.totalPlayers >= 3 then
			p3_id.setText(_SRC_intToString(gameSet) );	
			p3_hunters.setText(_SRC_intToString(scoreHunters[2]) );	
			p3_pts.setText(_SRC_intToString(scoreValues[2]) );	
			p3_total.setText(_SRC_intToString(totalScoreValues[2]) );				
		end	

		await 500ms;
				
		var AnyKeyContinue contKey;
		await contKey.pressed;	
		#else
			// Aguarda um tempo para reiniciar uma partida
			await 500ms;			
		#endif
	end
		
with
	// Redesenha a tela
    every SDL_REDRAW do
        _SDL_RenderPresent(&&renderer!);
    end
end

escape 0;  
    

// e63b95a6905d278fb2ea187f8cad63ede552b4d6

